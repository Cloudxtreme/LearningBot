package fr.insarennes.learningbot.controller;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import javax.xml.stream.XMLStreamException;

import kc.micro.Thorn;
import robocode.BattleEndedEvent;
import robocode.BulletHitEvent;
import robocode.BulletMissedEvent;
import robocode.HitByBulletEvent;
import robocode.HitRobotEvent;
import robocode.HitWallEvent;
import robocode.ScannedRobotEvent;
import fr.insarennes.learningbot.model.Coordinates;
import fr.insarennes.learningbot.model.DecisionTree;
import fr.insarennes.learningbot.model.LearnedData;

/**
 * A robot based on an existing one, however this one will improve itself over time,
 * by building and following a decision tree.
 */
public class LearningBot extends Thorn {
//CONSTANTS
	/** The file which contains the decision tree **/
	private static final String TREE_FILE = "learningbot.tree.xml";
	/** The default bullet power **/
	private static final double BULLET_POWER = 2.5; 
	
	private int FIXME_betterNameAndCleaner = 0;// in order to record data less often
	
//ATTRIBUTES
	/** The decision tree generated by BonzaiBoost (c) **/
	private static DecisionTree tree;
	/** All the data acquired during battle (static so that each LearningBot instance has access to it) **/ 
	private static List<LearnedData> knowledge = new ArrayList<LearnedData>();

//CONSTRUCTOR
	/**
	 * Class constructor
	 */
	public LearningBot() {
		super();
	}

//ACCESSORS
	/**
	 * @return The last saved data, or null if no data
	 */
	public LearnedData getLastData() {
		return (knowledge.size() > 0) ? knowledge.get(knowledge.size()-1) : null;
	}
	
//MODIFIERS
	
//OTHER METHODS
	/**
	 * This method is launched when a battle starts
	 */
	public void run() {
		loadTree();
		
		if (tree == null) {
			super.run();
		}
		else {
			List<Coordinates> steps = new LinkedList<Coordinates>();
			steps.add(new Coordinates(getBattleFieldWidth()/6, getBattleFieldHeight()/6));
			steps.add(new Coordinates((getBattleFieldWidth()/6)*5, (getBattleFieldHeight()/6)*5));
			steps.add(new Coordinates(getBattleFieldWidth()/6, (getBattleFieldHeight()/6)*5));
			steps.add(new Coordinates((getBattleFieldWidth()/6)*5, getBattleFieldHeight()/6));
			
			
			setTurnGunRight(Double.POSITIVE_INFINITY);
			execute();
			
			
			while (true) {
				for (Coordinates currentStep : steps) {
					moveTo(currentStep);
				}
				
			}
		}
			
			
	}
	
	private void moveTo(Coordinates to) {
		//orientation
		//tournerdroite de getVect - orientation actuelle
		turnRight(Coordinates.getVectorDirection(new Coordinates(getX(), getY()), to) - getHeading());
		
		//movement
		ahead(Math.sqrt(Math.pow(to.getX() - getX(), 2) + Math.pow(to.getY() - getY(), 2)));
		
	}
	
	/**
	 * This method is called when a robot is detected
	 */
	public void onScannedRobot(ScannedRobotEvent e) {
		//if ((FIXME_betterNameAndCleaner++) % 5 == 0)
			knowledge.add(new LearnedData(this, e));
		if(tree == null) {
			super.onScannedRobot(e);
		}
		else {//if ((FIXME_betterNameAndCleaner++) % 5 == 0) {
			
			//Decision for shoot
			if(tree.doWeShoot(this)) {
				fireBullet(BULLET_POWER);
				System.err.println("Proudly fired with BonzaiBoost (c)");
			}
			
			//Decision for direction
			String direction = tree.whereDoWeGo(this);
			switch(direction) {
				case "forward":
				case "stay":
				case "backward":
					break;
				case "left":
					setTurnLeft(90);
					break;
				case "right":
					setTurnRight(90);
					break;
			}
			
			//Decision for gun direction
		/*	String gunDirection = tree.whatGunOrientation(this);
			switch(gunDirection) {
				case "front":
					break;
				case "back":
					setTurnGunLeft(180);
					break;
				case "left":
					setTurnGunLeft(90);
					break;
				case "right":
					setTurnGunRight(90);
					break;
			}*///FIXME
			
			execute();//FIXME shouldn't be after setAhead ?
			
			//Hardcoded speed
			if(!direction.equals("stay")) {
				double distance = 70;
				if(direction.equals("backward")) {
					setBack(distance);
				} else {
					setAhead(distance);
				}
			}
		}
	}
	
	public void onBulletHit(BulletHitEvent e) {
		if (tree == null) {	
			super.onBulletHit(e);
		}
		for(int i=1; i <= 10 && i <= knowledge.size(); i++) {
			knowledge.get(knowledge.size()-i).setShootSuccesful();
		}
	}
	
	public void onBulletMissed(BulletMissedEvent e) {
		if(tree == null) {
			super.onBulletMissed(e);
		}
		setLastGunDirectionWrong();
	}
	
	public void onHitWall(HitWallEvent e) {
		if(tree == null) {
			super.onHitWall(e);
		}
		setLastDirectionWrong();
	}
	
	public void onHitRobot(HitRobotEvent e) {
		if(tree == null) {
			super.onHitRobot(e);
		}
		setLastDirectionWrong();
	}
	
	public void onHitByBullet(HitByBulletEvent e) {
		if(tree == null) {
			super.onHitByBullet(e);
		}
		setLastDirectionWrong();
	}
	
	public void onBattleEnded(BattleEndedEvent e) {
		//Save data in filesystem
		if(knowledge.size() > 0) {
			LearnedDataWriter ldw = new LearnedDataWriter();
			try {
				ldw.write(knowledge, getDataFile("learningbot.data"), getDataFile("learningbot.names"));
			} catch (IOException e1) {
				e1.printStackTrace();
				System.err.println("Failed to save collected data.");
			}
		} else {
			System.err.println("No data to save.");
		}
		
		super.onBattleEnded(e);
	}
	
	/**
	 * Tries to load tree from XML file
	 */
	private void loadTree() {
		//Load tree if needed
		if(tree == null) {
			DecisionTreeParser dtp = new DecisionTreeParser();
			try {
				File treeXml = getDataFile(TREE_FILE);
				if(treeXml.length() > 0) {
					tree = dtp.parse(treeXml);
				} else {
					//Delete the file created by getDataFile
					treeXml.delete();
				}
			} catch (FileNotFoundException | XMLStreamException e) {
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Sets the last used direction as wrong in data
	 */
	private void setLastDirectionWrong() {
		String oppositeDirection;
		switch(knowledge.get(knowledge.size()-1).getValue("direction")) {
			case "forward":
				oppositeDirection = "backward";
				break;
			case "backward":
				oppositeDirection = "forward";
				break;
			case "stay":
				oppositeDirection = "forward";
				break;
			case "left":
				oppositeDirection = "right";
				break;
			case "right":
				oppositeDirection = "left";
				break;
			default:
				oppositeDirection = "backward";
		}
		knowledge.get(knowledge.size()-1).setDirection(oppositeDirection);
	}
	
	/**
	 * Sets the last used direction for gun as wrong in data
	 */
	private void setLastGunDirectionWrong() {
		String oppositeDirection;
		switch(knowledge.get(knowledge.size()-1).getValue("gundirection")) {
			case "front":
				oppositeDirection = "back";
				break;
			case "back":
				oppositeDirection = "front";
				break;
			case "left":
				oppositeDirection = "right";
				break;
			case "right":
				oppositeDirection = "left";
				break;
			default:
				oppositeDirection = "back";
		}
		knowledge.get(knowledge.size()-1).setGunDirection(oppositeDirection);
	}
}
