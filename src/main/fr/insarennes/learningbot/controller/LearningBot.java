package fr.insarennes.learningbot.controller;

import java.awt.Color;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

import javax.xml.stream.XMLStreamException;

import kc.micro.Thorn;
import robocode.BattleEndedEvent;
import robocode.Bullet;
import robocode.BulletHitEvent;
import robocode.BulletMissedEvent;
import robocode.HitByBulletEvent;
import robocode.HitRobotEvent;
import robocode.HitWallEvent;
import robocode.ScannedRobotEvent;
import fr.insarennes.learningbot.model.Coordinates;
import fr.insarennes.learningbot.model.DecisionTree;
import fr.insarennes.learningbot.model.LearnedData;

/**
 * A robot based on an existing one, however this one will improve itself over time,
 * by building and following a decision tree.
 */
public class LearningBot extends Thorn {
//CONSTANTS
	/** The file which contains the decision tree **/
	private static final String TREE_FILE = "learningbot.tree.xml";
	/** The default bullet power **/
	private static final double BULLET_POWER = 1.0; //shouldn't it be little power, since accuracy is awful?
		
//ATTRIBUTES
	/** The decision tree generated by BonzaiBoost (c) **/
	private static DecisionTree tree;
	/** All the data acquired during battle (static so that each LearningBot instance has access to it) **/ 
	private static List<LearnedData> knowledge = new ArrayList<LearnedData>();

//CONSTRUCTOR
	/**
	 * Class constructor
	 */
	public LearningBot() {
		super();
	}

//ACCESSORS
	/**
	 * @return The last saved data, or null if no data
	 */
	public LearnedData getLastData() {
		return (knowledge.size() > 0) ? knowledge.get(knowledge.size()-1) : null;
	}
	
//MODIFIERS
	
//OTHER METHODS
	/**
	 * This method is launched when a battle starts
	 */
	public void run() {
		loadTree();
		
		setAllColors(Color.GREEN);
		
		super.run();
		//TODO virer tous les codes commentés une fois qu'on sait que ça marche sans
/*		if (tree == null) {
			super.run();
		}
		else {
			List<Coordinates> steps = new LinkedList<Coordinates>();
			steps.add(new Coordinates(getBattleFieldWidth()/6, getBattleFieldHeight()/6));
			steps.add(new Coordinates((getBattleFieldWidth()/6)*5, (getBattleFieldHeight()/6)*5));
			steps.add(new Coordinates(getBattleFieldWidth()/6, (getBattleFieldHeight()/6)*5));
			steps.add(new Coordinates((getBattleFieldWidth()/6)*5, getBattleFieldHeight()/6));
			
			
			setTurnGunRight(Double.POSITIVE_INFINITY);
			execute();
			
			
			while (true) {
				for (Coordinates currentStep : steps) {
					moveTo(currentStep);
				}
				
			}
		}
	*/		
			
	}
	
	/**
	 * Moves the robot to a certain point on the map, using Robocode's axes.
	 * Returns when the robot has arrived. (possibly before if there has been an error while moving)
	 * @param to
	 */
	private void moveTo(Coordinates to) {
		//orientation
		//tournerdroite de getVect - orientation actuelle
		turnRight(Coordinates.getVectorDirection(new Coordinates(getX(), getY()), to) - getHeading());
		
		//movement
		ahead(Math.sqrt(Math.pow(to.getX() - getX(), 2) + Math.pow(to.getY() - getY(), 2)));
		
	}
	
	/* REDEFINING FIRING (whether the bot should actually shoot or not) */
	@Override
	public void fire(double power) {
		if (tree == null || tree.doWeShoot(this))
			super.fire(power);
	}
	
	@Override
	public Bullet fireBullet(double power) {
		return (tree == null || tree.doWeShoot(this)) ? super.fireBullet(power) : null;
	}
	
	@Override
	public void setFire(double power) {
		if (tree == null || tree.doWeShoot(this))
			super.setFire(power);
		else
			System.err.println("Nope, won't shoot that one");
	}
	
	@Override
	public Bullet setFireBullet(double power) {
		return (tree == null || tree.doWeShoot(this)) ? super.fireBullet(power) : null;
	}
	
	
	/**
	 * This method is called when a robot is detected
	 */
	public void onScannedRobot(ScannedRobotEvent e) {
		knowledge.add(new LearnedData(this, e));
		
		if (tree != null && tree.doWeShoot(this) && getGunHeat() == 0) {
			fire(BULLET_POWER); // tree will be looked at twice, use super.setFire instead if you need perf.
			System.err.println("Proudly fired with BonzaiBoost (c)");
		}
			
		
		super.onScannedRobot(e);
		
		
		/*if(tree == null) {
			super.onScannedRobot(e);
		}
		else {
			
			//Decision for shoot
			if(tree.doWeShoot(this)) {
				fireBullet(BULLET_POWER);
				System.err.println("Proudly fired with BonzaiBoost (c)");
			}
			
			//Decision for direction
			String direction = tree.whereDoWeGo(this);
			switch(direction) {
				case "forward":
				case "stay":
				case "backward":
					break;
				case "left":
					setTurnLeft(90);
					break;
				case "right":
					setTurnRight(90);
					break;
			}
			*/
			//Decision for gun direction
		/*	String gunDirection = tree.whatGunOrientation(this);
			switch(gunDirection) {
				case "front":
					break;
				case "back":
					setTurnGunLeft(180);
					break;
				case "left":
					setTurnGunLeft(90);
					break;
				case "right":
					setTurnGunRight(90);
					break;
			}*///FIXME
			
		/*	execute();//FIXME shouldn't be after setAhead ?
			
			//Hardcoded speed
			if(!direction.equals("stay")) {
				double distance = 70;
				if(direction.equals("backward")) {
					setBack(distance);
				} else {
					setAhead(distance);
				}
			}
		}*/
	}
	
	public void onBulletHit(BulletHitEvent e) {
		/*if (tree == null) {	
			super.onBulletHit(e);
		}*/
		
		//The last X circumstances were thus presumably good times to shoot.
		for(int i=1; i <= 10 && i <= knowledge.size(); i++) {
			knowledge.get(knowledge.size()-i).setShootSuccesful();
		}
		
		super.onBulletHit(e);
	}
	
	public void onBulletMissed(BulletMissedEvent e) {
	/*	if(tree == null) {
			super.onBulletMissed(e);
		}
		setLastGunDirectionWrong();
		*/
		super.onBulletMissed(e);
	}
	
	public void onHitWall(HitWallEvent e) {
	/*	if(tree == null) {
			super.onHitWall(e);
		}
		setLastDirectionWrong();
		*/
		
		super.onHitWall(e);
	}
	
	public void onHitRobot(HitRobotEvent e) {
	/*	if(tree == null) {
			super.onHitRobot(e);
		}
		setLastDirectionWrong();
		*/
		super.onHitRobot(e);
	}
	
	public void onHitByBullet(HitByBulletEvent e) {
		/*if(tree == null) {
			super.onHitByBullet(e);
		}
		setLastDirectionWrong();
		*/
		super.onHitByBullet(e);
	}
	
	public void onBattleEnded(BattleEndedEvent e) {
		//Save data in filesystem
		if(knowledge.size() > 0) {
			LearnedDataWriter ldw = new LearnedDataWriter();
			try {
				ldw.write(knowledge, getDataFile("learningbot.data"), getDataFile("learningbot.names"));
			} catch (IOException e1) {
				e1.printStackTrace();
				System.err.println("Failed to save collected data.");
			}
		} else {
			System.err.println("No data to save.");
		}
		
		super.onBattleEnded(e);
	}
	
	/**
	 * Tries to load tree from XML file
	 */
	private void loadTree() {
		//Load tree if needed
		if(tree == null) {
			DecisionTreeParser dtp = new DecisionTreeParser();
			try {
				File treeXml = getDataFile(TREE_FILE);
				if(treeXml.length() > 0) {
					tree = dtp.parse(treeXml);
				} else {
					//Delete the file created by getDataFile
					treeXml.delete();
				}
			} catch (FileNotFoundException | XMLStreamException e) {
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Sets the last used direction as wrong in data
	 */
	private void setLastDirectionWrong() {
		String oppositeDirection;
		switch(knowledge.get(knowledge.size()-1).getValue("direction")) {
			case "forward":
				oppositeDirection = "backward";
				break;
			case "backward":
				oppositeDirection = "forward";
				break;
			case "stay":
				oppositeDirection = "forward";
				break;
			case "left":
				oppositeDirection = "right";
				break;
			case "right":
				oppositeDirection = "left";
				break;
			default:
				oppositeDirection = "backward";
		}
		knowledge.get(knowledge.size()-1).setDirection(oppositeDirection);
	}
	
	/**
	 * Sets the last used direction for gun as wrong in data
	 */
	private void setLastGunDirectionWrong() {
		String oppositeDirection;
		switch(knowledge.get(knowledge.size()-1).getValue("gundirection")) {
			case "front":
				oppositeDirection = "back";
				break;
			case "back":
				oppositeDirection = "front";
				break;
			case "left":
				oppositeDirection = "right";
				break;
			case "right":
				oppositeDirection = "left";
				break;
			default:
				oppositeDirection = "back";
		}
		knowledge.get(knowledge.size()-1).setGunDirection(oppositeDirection);
	}
}
